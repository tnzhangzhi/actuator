锁
1.锁开销：锁占用内存、CPU，初始化和销毁锁，获取和释放锁时间
2.锁竞争：一个进程或线程试图获取另一个进程或线程持有的锁，就会发生锁竞争。锁粒度越小，发生锁竞争的可能性就越小
3.死锁：至少两个任务中的每一个都等待另一个任务持有的锁的情况

锁粒度
锁粒度是衡量锁保护的数据量大小，通常选择粗粒度的锁(锁的数量少，每个锁保护大量的数据)，
在当单进程访问受保护的数据时锁开销小，但是当多个进程同时访问时性能很差。
因为增大了锁的竞争。相反，使用细粒度的锁(锁数量多，每个锁保护少量的数据)增加了锁的开销但是减少了锁竞争。例如数据库中，锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁。

锁的种类（这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计）
乐观锁/悲观锁
公平锁/非公平锁
独享锁/共享锁
互斥锁/读写锁
可重入锁
分段锁
自旋锁
偏向锁/轻量级锁/重量级锁

1.乐观锁与悲观锁

乐观锁是一种乐观思想，即乐观的认为读多写少，遇到并发写的可能性低。每次拿数据的时候认为别人不会修改，所以不上锁，
但是在更新数据时候回去判断在此期间别人是否有修改过数据，采取在写时先读取版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
如果失败则重复读-比较-写的操作
java中的乐观锁基本上通过CAS实现，CAS是一种更新的原子操作

悲观锁是一种悲观思想，即悲观的认为写多，遇到并发写的可能性大，每次去拿数据时候都认为别人会修改，所以每次读写数据的时候都会上锁，
这样别人读写这个数据都会block直到拿到锁。
java 中的悲观锁就是syncnizted，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到锁才会转换为悲观锁，如retreendlock；

2.公平锁与非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁
非公平锁反之，有可能造成优先级反转，饥饿现象
对于java ReentrantLock 可以通过构造函数设置是否为公平锁，默认非公平锁，非公平锁的优点是吞吐量高于非公平锁
synchronized是非公平锁

3.独享锁与共享锁
独享锁是指该锁一次只能被一个线程所持有；共享锁是指该锁可被多个线程所持有
对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
读锁的共享锁可保证并发读是非常高效的，读写、写读 、写写的过程是互斥的。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于synchronized而言，当然是独享锁


4.互斥锁与读写锁
上面说到的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock；读写锁在Java中的具体实现就是ReadWriteLock

5.可重入锁
可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
对于Java ReentrantLock而言, 其名字是Reentrant Lock即是重新进入锁。对于synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁

6.分段锁
分段锁其实是一种锁的设计，并不是具体的一种锁，分段锁的设计目的是细化锁的粒度

7.自旋锁
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，
这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU

8.偏向锁/轻量级锁/重量级锁
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低

Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。
锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。
这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁。后面将会对这四种状态进行详细说明。

LinkedBlockingQueue
CopyOnWriteArrayList


1.为什么wait()必须在同步代码中调用（synchronized）如下解释：
This method should only be called by a thread that is the owner of this object's monitor
IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
因为synchronized修饰的代码，在生成的字节码中在开始和结束地方包含monitor enter 和monitor exit 指令

2.obj.wait()调用时必须拿到当前对象的监视器monitor对象,object monitor对象有两个队列，entry list 和 wait set， owner指向获得monitor对象的线程，没有获取到锁的进入entry list，等待锁状态blocked，调用了wait()的进入 wait set，只有等调用了obj.notify()
才能重新从之前wait()的地方继续向下执行,切需要等调用obj.notify的同步方法执行完才执行wait()之后的代码

3.notify随机唤醒一个，notifyall唤醒所有

测试时候，sleep() 时状态 java.lang.Thread.State: TIMED_WAITING   waiting on condition
调用了wait（）的状态 java.lang.Thread.State: WAITING   object.wait()

与Object类的wait/notify机制相比，park/unpark有两个优点：

以thread为操作对象更符合阻塞线程的直观定义
操作更精准，可以准确地唤醒某一个线程。
区别是:notify随机唤醒一个线程，notifyAll唤醒所有等待的线程,增加了灵活性